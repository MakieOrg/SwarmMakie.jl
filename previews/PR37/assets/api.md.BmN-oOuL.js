import{_ as n,C as d,c as l,o as c,aA as r,j as o,G as a,a as s,w as i}from"./chunks/framework.BRClR9sr.js";const x=JSON.parse('{"title":"API Reference","description":"","frontmatter":{},"headers":[],"relativePath":"api.md","filePath":"api.md","lastUpdated":null}'),p={name:"api.md"},h={class:"jldocstring custom-block",open:""},m={class:"jldocstring custom-block",open:""},g={class:"jldocstring custom-block",open:""},k={class:"jldocstring custom-block",open:""},u={class:"jldocstring custom-block",open:""},f={class:"jldocstring custom-block",open:""},b={class:"jldocstring custom-block",open:""},w={class:"jldocstring custom-block",open:""},y={class:"jldocstring custom-block",open:""},S={class:"jldocstring custom-block",open:""};function j(M,e,T,v,C,_){const t=d("Badge");return c(),l("div",null,[e[40]||(e[40]=r('<h1 id="API-Reference" tabindex="-1">API Reference <a class="header-anchor" href="#API-Reference" aria-label="Permalink to &quot;API Reference {#API-Reference}&quot;">​</a></h1><ul><li><a href="#SwarmMakie.Beeswarm"><code>SwarmMakie.Beeswarm</code></a></li><li><a href="#SwarmMakie.JitterAlgorithm"><code>SwarmMakie.JitterAlgorithm</code></a></li><li><a href="#SwarmMakie.NoBeeswarm"><code>SwarmMakie.NoBeeswarm</code></a></li><li><a href="#SwarmMakie.PseudorandomJitter"><code>SwarmMakie.PseudorandomJitter</code></a></li><li><a href="#SwarmMakie.QuasirandomJitter"><code>SwarmMakie.QuasirandomJitter</code></a></li><li><a href="#SwarmMakie.SimpleBeeswarm"><code>SwarmMakie.SimpleBeeswarm</code></a></li><li><a href="#SwarmMakie.UniformJitter"><code>SwarmMakie.UniformJitter</code></a></li><li><a href="#SwarmMakie.WilkinsonBeeswarm"><code>SwarmMakie.WilkinsonBeeswarm</code></a></li><li><a href="#SwarmMakie.beeswarm"><code>SwarmMakie.beeswarm</code></a></li><li><a href="#SwarmMakie.beeswarm!"><code>SwarmMakie.beeswarm!</code></a></li></ul>',2)),o("details",h,[o("summary",null,[e[0]||(e[0]=o("a",{id:"SwarmMakie.Beeswarm",href:"#SwarmMakie.Beeswarm"},[o("span",{class:"jlbinding"},"SwarmMakie.Beeswarm")],-1)),e[1]||(e[1]=s()),a(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),e[3]||(e[3]=o("p",null,[o("code",null,"Beeswarm"),s(" is the plot type associated with plotting function "),o("code",null,"beeswarm"),s(". Check the docstring for "),o("code",null,"beeswarm"),s(" for further information.")],-1)),a(t,{type:"info",class:"source-link",text:"source"},{default:i(()=>[...e[2]||(e[2]=[o("a",{href:"https://github.com/MakieOrg/Makie.jl/blob/v0.24.6/src/recipes.jl#L528",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),o("details",m,[o("summary",null,[e[4]||(e[4]=o("a",{id:"SwarmMakie.JitterAlgorithm",href:"#SwarmMakie.JitterAlgorithm"},[o("span",{class:"jlbinding"},"SwarmMakie.JitterAlgorithm")],-1)),e[5]||(e[5]=s()),a(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),e[7]||(e[7]=o("p",null,"The abstract type for jitter algorithms, which are markersize-agnostic.",-1)),a(t,{type:"info",class:"source-link",text:"source"},{default:i(()=>[...e[6]||(e[6]=[o("a",{href:"https://github.com/MakieOrg/SwarmMakie.jl/blob/cf3fca78d6bfe5c0465a2cf8aa2794a5a5c449be/src/algorithms/jitter.jl#L19",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),o("details",g,[o("summary",null,[e[8]||(e[8]=o("a",{id:"SwarmMakie.NoBeeswarm",href:"#SwarmMakie.NoBeeswarm"},[o("span",{class:"jlbinding"},"SwarmMakie.NoBeeswarm")],-1)),e[9]||(e[9]=s()),a(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),e[11]||(e[11]=o("p",null,[s("A simple no-op algorithm, which causes the scatter plot to be drawn as if you called "),o("code",null,"scatter"),s(" and not "),o("code",null,"beeswarm"),s(".")],-1)),a(t,{type:"info",class:"source-link",text:"source"},{default:i(()=>[...e[10]||(e[10]=[o("a",{href:"https://github.com/MakieOrg/SwarmMakie.jl/blob/cf3fca78d6bfe5c0465a2cf8aa2794a5a5c449be/src/recipe.jl#L62",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),o("details",k,[o("summary",null,[e[12]||(e[12]=o("a",{id:"SwarmMakie.PseudorandomJitter",href:"#SwarmMakie.PseudorandomJitter"},[o("span",{class:"jlbinding"},"SwarmMakie.PseudorandomJitter")],-1)),e[13]||(e[13]=s()),a(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),e[15]||(e[15]=r('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">PseudorandomJitter</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre></div><p>A jitter algorithm that uses a pseudorandom distribution to create the jitter. A pseudorandom distribution is a uniform distribution weighted by the PDF of the data.</p>',2)),a(t,{type:"info",class:"source-link",text:"source"},{default:i(()=>[...e[14]||(e[14]=[o("a",{href:"https://github.com/MakieOrg/SwarmMakie.jl/blob/cf3fca78d6bfe5c0465a2cf8aa2794a5a5c449be/src/algorithms/jitter.jl#L34-L39",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),o("details",u,[o("summary",null,[e[16]||(e[16]=o("a",{id:"SwarmMakie.QuasirandomJitter",href:"#SwarmMakie.QuasirandomJitter"},[o("span",{class:"jlbinding"},"SwarmMakie.QuasirandomJitter")],-1)),e[17]||(e[17]=s()),a(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),e[19]||(e[19]=r('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">QuasirandomJitter</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre></div><p>A jitter algorithm that uses a quasirandom (van der Corput) distribution weighted by the data&#39;s pdf to jitter the data points.</p>',2)),a(t,{type:"info",class:"source-link",text:"source"},{default:i(()=>[...e[18]||(e[18]=[o("a",{href:"https://github.com/MakieOrg/SwarmMakie.jl/blob/cf3fca78d6bfe5c0465a2cf8aa2794a5a5c449be/src/algorithms/jitter.jl#L45-L50",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),o("details",f,[o("summary",null,[e[20]||(e[20]=o("a",{id:"SwarmMakie.SimpleBeeswarm",href:"#SwarmMakie.SimpleBeeswarm"},[o("span",{class:"jlbinding"},"SwarmMakie.SimpleBeeswarm")],-1)),e[21]||(e[21]=s()),a(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),e[23]||(e[23]=r('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">SimpleBeeswarm</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre></div><p>A simple beeswarm implementation, that minimizes overlaps. This is the default algorithm used in <code>beeswarm</code>.</p><p>This algorithm dodges in <code>x</code> but preserves the exact <code>y</code> coordinate of each point. If you want a more organized appearance and don&#39;t need to preserve the exact y coordinates, you can try <a href="/SwarmMakie.jl/previews/PR37/api#SwarmMakie.WilkinsonBeeswarm"><code>WilkinsonBeeswarm</code></a>.</p>',3)),a(t,{type:"info",class:"source-link",text:"source"},{default:i(()=>[...e[22]||(e[22]=[o("a",{href:"https://github.com/MakieOrg/SwarmMakie.jl/blob/cf3fca78d6bfe5c0465a2cf8aa2794a5a5c449be/src/algorithms/simple.jl#L4-L12",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),o("details",b,[o("summary",null,[e[24]||(e[24]=o("a",{id:"SwarmMakie.UniformJitter",href:"#SwarmMakie.UniformJitter"},[o("span",{class:"jlbinding"},"SwarmMakie.UniformJitter")],-1)),e[25]||(e[25]=s()),a(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),e[27]||(e[27]=r('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">UniformJitter</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre></div><p>A jitter algorithm that uses a uniform distribution to create the jitter.</p>',2)),a(t,{type:"info",class:"source-link",text:"source"},{default:i(()=>[...e[26]||(e[26]=[o("a",{href:"https://github.com/MakieOrg/SwarmMakie.jl/blob/cf3fca78d6bfe5c0465a2cf8aa2794a5a5c449be/src/algorithms/jitter.jl#L24-L28",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),o("details",w,[o("summary",null,[e[28]||(e[28]=o("a",{id:"SwarmMakie.WilkinsonBeeswarm",href:"#SwarmMakie.WilkinsonBeeswarm"},[o("span",{class:"jlbinding"},"SwarmMakie.WilkinsonBeeswarm")],-1)),e[29]||(e[29]=s()),a(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),e[31]||(e[31]=r('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">WilkinsonBeeswarm</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre></div><p>A beeswarm algorithm that implements Leland Wilkinson&#39;s original dot-hist algorithm.</p><p>This is essentially a histogram with dots, where all dots are binned in the <code>y</code> (non-categorical) direction, and then dodged in the <code>x</code> (categorical) direction.</p><p>Original y-coordinates are not preserved, and if you want that try <a href="/SwarmMakie.jl/previews/PR37/api#SwarmMakie.SimpleBeeswarm"><code>SimpleBeeswarm</code></a> instead.</p>',4)),a(t,{type:"info",class:"source-link",text:"source"},{default:i(()=>[...e[30]||(e[30]=[o("a",{href:"https://github.com/MakieOrg/SwarmMakie.jl/blob/cf3fca78d6bfe5c0465a2cf8aa2794a5a5c449be/src/algorithms/wilkinson.jl#L18-L27",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),o("details",y,[o("summary",null,[e[32]||(e[32]=o("a",{id:"SwarmMakie.beeswarm",href:"#SwarmMakie.beeswarm"},[o("span",{class:"jlbinding"},"SwarmMakie.beeswarm")],-1)),e[33]||(e[33]=s()),a(t,{type:"info",class:"jlObjectType jlFunction",text:"Function"})]),e[35]||(e[35]=r(`<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">beeswarm</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(x, y)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">beeswarm</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(positions)</span></span></code></pre></div><p><code>beeswarm</code> is a <code>PointBased</code> recipe like <code>scatter</code>, accepting all of <code>scatter</code>&#39;s input.</p><p>It displaces points which would otherwise overlap in the x-direction by binning in the y direction.</p><p><strong>Example</strong></p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">using</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Makie, SwarmMakie</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">beeswarm</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">ones</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">100</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">), </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">randn</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">100</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">); color </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> rand</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(RGBf, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">100</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">))</span></span></code></pre></div><p><strong>Plot type</strong></p><p>The plot type alias for the <code>beeswarm</code> function is <code>Beeswarm</code>.</p><p><strong>Attributes</strong></p><p><strong><code>algorithm</code></strong> = <code>:default</code> — The algorithm used to lay out the beeswarm markers.</p><p><strong><code>alpha</code></strong> = <code>1.0</code> — The alpha value of the colormap or color attribute. Multiple alphas like in <code>plot(alpha=0.2, color=(:red, 0.5)</code>, will get multiplied.</p><p><strong><code>clip_planes</code></strong> = <code>@inherit clip_planes automatic</code> — Clip planes offer a way to do clipping in 3D space. You can set a Vector of up to 8 <code>Plane3f</code> planes here, behind which plots will be clipped (i.e. become invisible). By default clip planes are inherited from the parent plot or scene. You can remove parent <code>clip_planes</code> by passing <code>Plane3f[]</code>.</p><p><strong><code>color</code></strong> = <code>@inherit markercolor</code> — Sets the color of the marker. If no color is set, multiple calls to <code>scatter!</code> will cycle through the axis color palette.</p><p><strong><code>colormap</code></strong> = <code>@inherit colormap :viridis</code> — Sets the colormap that is sampled for numeric <code>color</code>s. <code>PlotUtils.cgrad(...)</code>, <code>Makie.Reverse(any_colormap)</code> can be used as well, or any symbol from ColorBrewer or PlotUtils. To see all available color gradients, you can call <code>Makie.available_gradients()</code>.</p><p><strong><code>colorrange</code></strong> = <code>automatic</code> — The values representing the start and end points of <code>colormap</code>.</p><p><strong><code>colorscale</code></strong> = <code>identity</code> — The color transform function. Can be any function, but only works well together with <code>Colorbar</code> for <code>identity</code>, <code>log</code>, <code>log2</code>, <code>log10</code>, <code>sqrt</code>, <code>logit</code>, <code>Makie.pseudolog10</code>, <code>Makie.Symlog10</code>, <code>Makie.AsinhScale</code>, <code>Makie.SinhScale</code>, <code>Makie.LogScale</code>, <code>Makie.LuptonAsinhScale</code>, and <code>Makie.PowerScale</code>.</p><p><strong><code>cycle</code></strong> = <code>[:color]</code> — Sets which attributes to cycle when creating multiple plots</p><p><strong><code>depth_shift</code></strong> = <code>0.0</code> — Adjusts the depth value of a plot after all other transformations, i.e. in clip space, where <code>-1 &lt;= depth &lt;= 1</code>. This only applies to GLMakie and WGLMakie and can be used to adjust render order (like a tunable overdraw).</p><p><strong><code>depthsorting</code></strong> = <code>false</code> — Enables depth-sorting of markers which can improve border artifacts. Currently supported in GLMakie only.</p><p><strong><code>direction</code></strong> = <code>:y</code> — Controls the direction of the beeswarm. Can be <code>:y</code> (vertical) or <code>:x</code> (horizontal).</p><p><strong><code>distancefield</code></strong> = <code>nothing</code> — Optional distancefield used for e.g. font and bezier path rendering. Will get set automatically.</p><p><strong><code>dodge</code></strong> = <code>Makie.automatic</code> — Dodge can be used to separate beeswarms drawn at the same position. For this each beeswarm is given an integer value corresponding to its position relative to the given positions. E.g. with <code>positions = [1, 1, 1, 2, 2, 2]</code> we have 3 beeswarms at each position which can be separated by <code>dodge = [1, 2, 3, 1, 2, 3]</code>.</p><p><strong><code>dodge_gap</code></strong> = <code>0.03</code> — Sets the gap between dodged beeswarms relative to the size of the dodged beeswarms.</p><p><strong><code>font</code></strong> = <code>&quot;default&quot;</code> — Sets the font to be used for character markers</p><p><strong><code>fxaa</code></strong> = <code>false</code> — Adjusts whether the plot is rendered with fxaa (anti-aliasing, GLMakie only).</p><p><strong><code>gap</code></strong> = <code>0.2</code> — Gap space reserved from jitter columns as a fraction of width.</p><p><strong><code>glowcolor</code></strong> = <code>(:black, 0.0)</code> — Sets the color of the glow effect around the marker.</p><p><strong><code>glowwidth</code></strong> = <code>0.0</code> — Sets the size of a glow effect around the marker.</p><p><strong><code>highclip</code></strong> = <code>automatic</code> — The color for any value above the colorrange.</p><p><strong><code>inspectable</code></strong> = <code>@inherit inspectable</code> — Sets whether this plot should be seen by <code>DataInspector</code>. The default depends on the theme of the parent scene.</p><p><strong><code>inspector_clear</code></strong> = <code>automatic</code> — Sets a callback function <code>(inspector, plot) -&gt; ...</code> for cleaning up custom indicators in DataInspector.</p><p><strong><code>inspector_hover</code></strong> = <code>automatic</code> — Sets a callback function <code>(inspector, plot, index) -&gt; ...</code> which replaces the default <code>show_data</code> methods.</p><p><strong><code>inspector_label</code></strong> = <code>automatic</code> — Sets a callback function <code>(plot, index, position) -&gt; string</code> which replaces the default label generated by DataInspector.</p><p><strong><code>lowclip</code></strong> = <code>automatic</code> — The color for any value below the colorrange.</p><p><strong><code>marker</code></strong> = <code>@inherit marker</code> — Sets the scatter marker.</p><p><strong><code>marker_offset</code></strong> = <code>Vec3f(0)</code> — The offset of the marker from the given position in <code>markerspace</code> units. An offset of 0 corresponds to a centered marker.</p><p><strong><code>markersize</code></strong> = <code>@inherit markersize</code> — Sets the size of the marker by scaling it relative to its base size which can differ for each marker. A <code>Real</code> scales x and y dimensions by the same amount. A <code>Vec</code> or <code>Tuple</code> with two elements scales x and y separately. An array of either scales each marker separately. Humans perceive the area of a marker as its size which grows quadratically with <code>markersize</code>, so multiplying <code>markersize</code> by 2 results in a marker that is 4 times as large, visually.</p><p><strong><code>markerspace</code></strong> = <code>:pixel</code> — Sets the space in which <code>markersize</code> is given. See <code>Makie.spaces()</code> for possible inputs</p><p><strong><code>model</code></strong> = <code>automatic</code> — Sets a model matrix for the plot. This overrides adjustments made with <code>translate!</code>, <code>rotate!</code> and <code>scale!</code>.</p><p><strong><code>n_dodge</code></strong> = <code>Makie.automatic</code> — Sets the maximum integer for <code>dodge</code>. This sets how many beeswarms can be placed at a given position, controlling their width.</p><p><strong><code>nan_color</code></strong> = <code>:transparent</code> — The color for NaN values.</p><p><strong><code>overdraw</code></strong> = <code>false</code> — Controls if the plot will draw over other plots. This specifically means ignoring depth checks in GL backends</p><p><strong><code>rotation</code></strong> = <code>Billboard()</code> — Sets the rotation of the marker. A <code>Billboard</code> rotation is always around the depth axis.</p><p><strong><code>seed</code></strong> = <code>nothing</code> — Random seed for jitter algorithms.</p><p><strong><code>side</code></strong> = <code>:both</code> — The side towards which markers should extend. Can be <code>:left</code>, <code>:right</code>, or both.</p><p><strong><code>space</code></strong> = <code>:data</code> — Sets the transformation space for box encompassing the plot. See <code>Makie.spaces()</code> for possible inputs.</p><p><strong><code>ssao</code></strong> = <code>false</code> — Adjusts whether the plot is rendered with ssao (screen space ambient occlusion). Note that this only makes sense in 3D plots and is only applicable with <code>fxaa = true</code>.</p><p><strong><code>strokecolor</code></strong> = <code>@inherit markerstrokecolor</code> — Sets the color of the outline around a marker.</p><p><strong><code>strokewidth</code></strong> = <code>@inherit markerstrokewidth</code> — Sets the width of the outline around a marker.</p><p><strong><code>transform_marker</code></strong> = <code>false</code> — Controls whether the model matrix (without translation) applies to the marker itself, rather than just the positions. (If this is true, <code>scale!</code> and <code>rotate!</code> will affect the marker.</p><p><strong><code>transformation</code></strong> = <code>:automatic</code> — <em>No docs available.</em></p><p><strong><code>transparency</code></strong> = <code>false</code> — Adjusts how the plot deals with transparency. In GLMakie <code>transparency = true</code> results in using Order Independent Transparency.</p><p><strong><code>uv_offset_width</code></strong> = <code>(0.0, 0.0, 0.0, 0.0)</code> — <em>No docs available.</em></p><p><strong><code>visible</code></strong> = <code>true</code> — Controls whether the plot will be rendered or not.</p><p><strong><code>width</code></strong> = <code>Makie.automatic</code> — Width of the jitter columns in data space. By default the smallest difference between categories.</p>`,54)),a(t,{type:"info",class:"source-link",text:"source"},{default:i(()=>[...e[34]||(e[34]=[o("a",{href:"https://github.com/MakieOrg/Makie.jl/blob/v0.24.6/src/recipes.jl#L527-L659",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),o("details",S,[o("summary",null,[e[36]||(e[36]=o("a",{id:"SwarmMakie.beeswarm!",href:"#SwarmMakie.beeswarm!"},[o("span",{class:"jlbinding"},"SwarmMakie.beeswarm!")],-1)),e[37]||(e[37]=s()),a(t,{type:"info",class:"jlObjectType jlFunction",text:"Function"})]),e[39]||(e[39]=o("p",null,[o("code",null,"beeswarm!"),s(" is the mutating variant of plotting function "),o("code",null,"beeswarm"),s(". Check the docstring for "),o("code",null,"beeswarm"),s(" for further information.")],-1)),a(t,{type:"info",class:"source-link",text:"source"},{default:i(()=>[...e[38]||(e[38]=[o("a",{href:"https://github.com/MakieOrg/Makie.jl/blob/v0.24.6/src/recipes.jl#L529",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})])])}const A=n(p,[["render",j]]);export{x as __pageData,A as default};
